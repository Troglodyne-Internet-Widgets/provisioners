#!/usr/bin/env perl

package Trog::Provisioner::Config::Generator;

use strict;
use warnings;

use FindBin;
use FindBin::libs;

use YAML;
use File::Slurper;
use Config::Simple;
use Cwd();

use Text::Xslate;
use List::Util qw{uniq};
use Net::SFTP::Foreign;
use File::Path qw{make_path remove_tree};

#TODO chdir to bin loc/ ..

my $cfile = 'ipmap.cfg';
sub get_config {
    die "No ipmap available..." unless -f $cfile;
    my $c = Config::Simple->new( $cfile );

    my $global_conf = $c->param(-block => 'global');
    my $ip_conf     = $c->param(-block => 'ips');
    my $alias_conf  = $c->param(-block => 'aliases');
    my $ns_conf     = $c->param(-block => 'nameservers');
    return ($global_conf, $ip_conf, $alias_conf, $ns_conf);
}



my $pfile = 'recipes.yaml';
sub get_recipe_config {
    return {} unless $pfile;
    my $c = YAML::Load( File::Slurper::read_text($pfile) );
    return $c;
}


sub main {
    my @args = @_;

    # Only positional arg
    my $domain = shift @args;

    die "Must pass domain" unless $domain;

    my ($global_conf, $ip_conf, $alias_conf, $ns_conf) = get_config();

    my $basedir = $global_conf->{basedir};
    die "Must have basedir defined in global section of $cfile" unless $basedir;

    my $admin_user = $global_conf->{admin_user};
    die "Must set admin_user in global section of $cfile" unless $admin_user;
    
    my $admin_key = $global_conf->{admin_key};
    die "Must set admin_key in global section of $cfile" unless $admin_key;

    my $admin_gecos = $global_conf->{admin_gecos};
    die "Must set admin_gecos in global section of $cfile" unless $admin_gecos;

    my $admin_email = $global_conf->{admin_email};
    die "Must set admin_email in global section of $cfile" unless $admin_email;

    my $static_ip = $ip_conf->{$domain};
    die "Must set ip for $domain in ips section of $cfile" unless $static_ip;

    my $tld = $global_conf->{tld};
    die "Must set tld for $domain in global section of $cfile" unless $tld;

    my $tld_ip = $global_conf->{ip};
    die "Must set ip for $domain in global section of $cfile" unless $tld;


    my $fqdn = "$domain.$tld";

    my $cfg_dir = "$basedir/$fqdn";
    mkdir $cfg_dir;

    # Build a users.yaml
    my $user_conf =  {
        users => [
            {
                gecos => $admin_gecos,
                name  => $admin_user,
                shell => '/bin/bash',
                sudo => 'ALL=(ALL) NOPASSWD:ALL',
                ssh_import_id => [ $admin_key ],
            }
        ],
    };

    File::Slurper::write_binary("$cfg_dir/users.yaml", YAML::Dump($user_conf));

    my $rconf = get_recipe_config();
    my %fragments;

    my $provisioner_dir = Cwd::abs_path($FindBin::Bin."/../");
    my $root_scripts    = '/root/bin';
    my $hv_internal_ip  = get_hv_internal_ip();

    # There will always be some global config for a domain which ought be made available to the various modules
    my $global_config = delete $rconf->{$domain}{_global} // {};

    # There will always be data config
    my $data_config = delete $rconf->{$domain}{data};
    die "Must provide data configuation for $fqdn" unless $data_config;

    my %formatters = (
        tabinate => Text::Xslate::html_builder(sub {
            my $input = shift;
            $input =~ s/^\s*/\t/mg;
            return $input;
        }),
    );

    my $tt = Text::Xslate->new({
        path     => "templates/",
        syntax   => 'TTerse',
        function => \%formatters,
    }) || die "Could not initialize template dir";
    

    # TODO stop hardcoding some things, and document this in P::R
    my %provisioner_opts = (
        target_packager => 'deb',
        hv_internal_ip  => $hv_internal_ip,
        provisioner_dir => $provisioner_dir,
        script_loc      => $root_scripts,
        output_dir      => $cfg_dir,
    );

    foreach my $subdomain (keys(%$ip_conf)) {
        $alias_conf->{$subdomain} = _coerce_arrayref($alias_conf->{$subdomain});

        # Basically every single web host is gonna need its own mail/www cnames
        push(@{$alias_conf->{$subdomain}}, (map { "$_.$subdomain" } qw{www mail}));
        $alias_conf->{$subdomain} = [uniq @{$alias_conf->{$subdomain}}];
    }

    $global_config->{hv_ip}         = $hv_internal_ip;
    $global_config->{provisioner_dir} = $provisioner_dir;
    $global_config->{tld}           = $tld;
    $global_config->{admin_user}    = $admin_user;
    $global_config->{admin_email}   = $admin_email;
    $global_config->{domain}        = $fqdn;
    $global_config->{ipmap}         = $ip_conf;
    $global_config->{subdomain}     = $domain;
    $global_config->{aliases}       = $alias_conf;
    $global_config->{nameservers}   = $ns_conf;
    $global_config->{main_ip}       = $static_ip;
    $global_config->{tld_ip}        = $tld_ip;

    require Provisioner::Recipe::data;
    my $do = Provisioner::Recipe::data->new(%provisioner_opts);
    my $data_fragment = $do->render(%$global_config, %$data_config );

    # set the install_dir for configs to use from here
    $global_config->{install_dir}   = $data_config->{to};
    $global_config->{script_dir}    = $root_scripts;

    my (@pkgs, @generated);

	#XXX because everything needs openssl, we explicitly generate a self-signed FIRST.
	push(@pkgs, 'openssl');

	# Figure out whether the remote host is actually up
	my $target_is_up = 1;
	my $ssh = Net::SFTP::Foreign->new( host => $static_ip, user => $admin_user );
	$ssh->error and $target_is_up=0;

    # Build a makefile based on our configured recipes
    my @modules = sort keys(%{$rconf->{$domain}});
    foreach my $module (@modules) {
        require "Provisioner/Recipe/$module.pm" or die "Could not load provisioner recipe $module";
        my $builder = "Provisioner::Recipe::$module"->new(%provisioner_opts);
        my $pconf = $rconf->{$domain}{$module};
        my $aliases = $alias_conf->{$domain};
        my $full_aliases = [map { "$_.$tld" } @$aliases];
        $fragments{$module} = $builder->render(%$global_config, %$pconf, full_aliases => $full_aliases, modules => \@modules );
        push(@pkgs, ($builder->deps(%$pconf)));

		# Make dirs in the DATADIR needed by ssh
		foreach my $d ($builder->datadirs()) {
			#XXX regrettably, Net::SFTP::Foreign has a hideous bug where if the destdir exists, it barfs. dumb.
			#remove_tree("$data_config->{from}/$fqdn/$d", { safe => 1 });
			make_path("$data_config->{from}/$fqdn/$d") unless -d $d;
		}

		# Schlep over stuff from existing deployments
		if ( $target_is_up ) {
			my %tg = $builder->remote_files();
			foreach my $to_fetch (sort keys(%tg)) {
				print "Writing remote file $to_fetch as $data_config->{from}/$fqdn/$tg{$to_fetch}\n";
				my $num_copied = $ssh->rget(
					$to_fetch,
					"$data_config->{from}/$fqdn/$tg{$to_fetch}",
					wanted => sub { 1 },
					#XXX most of the 'errors' here are literally normal operation, so who cares lol
					on_error => sub { print $ssh->error()."\n" },
					overwrite => 1,
					newer_only => 1,
				);
				print "Wrote $num_copied files.\n"
			}
		}

        # Now build the various templates for the recipes
        my %tf = $builder->template_files(@modules);
        foreach my $template (sort keys(%tf)) {
            my $destination = "$cfg_dir/$tf{$template}";
            my $rendered = $builder->render_file("files/$template", %$global_config, %$pconf, full_aliases => $full_aliases, modules => \@modules );
            print "Writing $template as $destination\n";
            File::Slurper::write_binary( $destination, $rendered );
            push(@generated, $tf{$template});
        }
    }

    my $makefile = $tt->render('makefile.tt', { %$global_config, data_fragment => $data_fragment, fragments => \%fragments });
    print "Writing Makefile to $cfg_dir\n";
    File::Slurper::write_binary("$cfg_dir/Makefile", $makefile);

    my $extra_packages = join(', ', uniq @pkgs);
    # Build a provision.conf
    my $pconf = qq(
        image=https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img
        size=42949672960
        packages=openssh-server, openssh-client, rsync, $extra_packages
        contact_email=$admin_email
        ips=$static_ip
    );
    File::Slurper::write_binary("$cfg_dir/provision.conf", $pconf);

    # Gzip the Makefile & generated configs
    print "Tarring up Makefile and generated configuration\n";
    system(qw{tar -cz -C}, $cfg_dir, '-f', "$cfg_dir/data.tar.gz", "./Makefile", @generated);
    print "Done.\n";
    return 0;
}

sub get_hv_internal_ip {
    my $ip = qx{ip addr show dev virbr0 | grep inet | head -n1 | awk '{print \$2}' | sed -E 's#/[0-9]+\$##'};
    chomp $ip;
    return $ip;
}

sub _coerce_arrayref {
    my ($input) = @_;
    return [] unless $input;
    return ref $input eq 'ARRAY' ? $input : [$input];
}

main(@ARGV) unless caller;
